# Redis设计与实现

> 基于redis仓库提交: 84b3c18f7

## 数据结构

1. 动态字符串
   - 相关文件: sds.h sds.c
   - 多种长度类型: sdshdx，区别在于结构体首端用于记录buf已用长度与分配长度的整形不同(uint8_t,uint16_t ...)
   - 动态分配大小，当字符串长度小于1M时，x2增长，否则+1M
2. 链表-list
   - 相关文件: adlist.h adlist.c
3. 字典-dict
   - 相关文件: dict.h dict.c
   - 通过hash实现，当hash冲突时，使用链表解决，dict会记录hash表长度(length)及总数据数(used)
   - 当哈希冲突超过阈值时，会将hash表扩张至二倍。当dict_can_resize为真时，阈值为used>=length，否则为used / length > dict_force_resize_ratio (默认为5)
   - 扩张后会进行rehash，但该过程为渐进的式的，此时dict会持有两张hash表，第二张（新表）的长度为第一张的二倍。
     每次增删改查时，会扫描旧表对非空节点做数据迁移，当迁移了足够多的hash节点或路过了足够多的空节点时，停止扫描并记录下一次扫描位置。
     迁移完成后，释放旧表，并进行翻转
4. 跳跃表: zskiplist
   - 相关文件: server.h z_zset.c
   - 跳跃表是在普通双向链表的基础上，在每个节点随机生成若干层（层数不小于1不大于32）
   - 当从head向tail遍历时，最下层形成了简单双向链表，节点间span为1，而层i(i>1)的span则记录了距离下一个层i节点的距离
   - zskiplist为每个节点记录分值(score)，zskiplist的排序规则为优先比较score大小，等score的情况下比较sds大小
   - 通过尽可能使用高层进行跳跃式遍历，在N不能远大于`2^32`（32为最高层数）时，查找和插入的平均时间复杂度为O(logN)，最坏O(N)，
     删除操作的时间复杂度为O(1)；当`N >> 2^32`时，跳跃表的优势将下降，最终查找和插入的平均时间复杂度将达到O(N)
   - 如果从head开始从前向后遍历，将途经节点的span值累加，我们可以得到该节点到head的距离，该距离为该节点的rank值。因此除了通过score、sds筛选外，
     zskiplist还允许通过rank筛选我们所需要的值
   - 跳跃表相较有有序数组，性能较差，但不需要一块完整的大的内存空间，且每个节点的大小可以不一致，更加灵活。
     而相较于红黑树，跳跃表的维护更加简单，但需要双倍的空间消耗（仅考虑不满足 N >> 2^32 的情况），但需要事先定好最高层级
5. 整数集合-intset
   - 相关文件: intset.h intset.c
   - 为了节均空间，intset的整数类型尽可能选小，初始使用int16类型。当插入数据超过范围时，再使用较大一级的整型，并扩充空间
   - intset为有序数组，查找时使用二分查找，时间复杂度为O(logN)
   - 每次插入数据都需要扩容，并使用内容拷贝的方式将插入位空出来，时间复杂度与查找一致
   - 需要注意的是intset在节点删除后，并不会尝试更小的数据类型