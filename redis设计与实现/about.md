# Redis设计与实现

> 基于redis仓库提交: 84b3c18f7

## 基本数据结构

1. 动态字符串
   - 相关文件: sds.h sds.c
   - 多种长度类型: sdshdx，区别在于结构体首端用于记录buf已用长度与分配长度的整形不同(uint8_t,uint16_t ...)
   - 动态分配大小，当字符串长度小于1M时，x2增长，否则+1M
2. 链表-list
   - 相关文件: adlist.h adlist.c
3. 字典-dict
   - 相关文件: dict.h dict.c
   - 通过hash实现，当hash冲突时，使用链表解决，dict会记录hash表长度(length)及总数据数(used)
   - 当哈希冲突超过阈值时，会将hash表扩张至二倍。当dict_can_resize为真时，阈值为used>=length，否则为used / length > dict_force_resize_ratio (默认为5)
   - 扩张后会进行rehash，但该过程为渐进的式的，此时dict会持有两张hash表，第二张（新表）的长度为第一张的二倍。
     每次增删改查时，会扫描旧表对非空节点做数据迁移，当迁移了足够多的hash节点或路过了足够多的空节点时，停止扫描并记录下一次扫描位置。
     迁移完成后，释放旧表，并进行翻转
4. 跳跃表: zskiplist
   - 相关文件: server.h z_zset.c
   - 跳跃表是在普通双向链表的基础上，在每个节点随机生成若干层（层数不小于1不大于32）
   - 当从head向tail遍历时，最下层形成了简单双向链表，节点间span为1，而层i(i>1)的span则记录了距离下一个层i节点的距离
   - zskiplist为每个节点记录分值(score)，zskiplist的排序规则为优先比较score大小，等score的情况下比较sds大小
   - 通过尽可能使用高层进行跳跃式遍历，在N不能远大于`2^32`（32为最高层数）时，查找和插入的平均时间复杂度为O(logN)，最坏O(N)，
     删除操作的时间复杂度为O(1)；当`N >> 2^32`时，跳跃表的优势将下降，最终查找和插入的平均时间复杂度将达到O(N)
   - 如果从head开始从前向后遍历，将途经节点的span值累加，我们可以得到该节点到head的距离，该距离为该节点的rank值。因此除了通过score、sds筛选外，
     zskiplist还允许通过rank筛选我们所需要的值
   - 跳跃表相较有有序数组，性能较差，但不需要一块完整的大的内存空间，且每个节点的大小可以不一致，更加灵活。
     而相较于红黑树，跳跃表的维护更加简单，但需要双倍的空间消耗（仅考虑不满足 N >> 2^32 的情况），但需要事先定好最高层级
5. 整数集合-intset
   - 相关文件: intset.h intset.c
   - 为了节均空间，intset的整数类型尽可能选小，初始使用int16类型。当插入数据超过范围时，再使用较大一级的整型，并扩充空间
   - intset为有序数组，查找时使用二分查找，时间复杂度为O(logN)
   - 每次插入数据都需要扩容，并使用内容拷贝的方式将插入位空出来，时间复杂度与查找一致
   - 需要注意的是intset在节点删除后，并不会尝试更小的数据类型
6. 压缩列表-ziplist
   - 相关文件: ziplist.h ziplist.c\
   - ziplist总体上由三个部分：头区域——含两个uint_32，分别记录ziplist占用总字节数、最后一个条目地址相对于ziplist头地址的偏移，以及一个u_int16记录条目数量；
     内容区域——使用连续内存块存放所有的条目，大小随条目增长；尾区域——只含一个uint_8，并被置为255标记ziplist结束。
   - 每个条目已包含三个部分：前一节点长度区域——用于记录前一节点（地址增加顺序）的长度信息，视长度大小本区域占用1或5个字节（意味着长度不应大于uint_32）；
     编码及长度区域——记录本条目的编码方式及内容值占用字节数量，视编码方式和内容长度占用1或2或5个字节；内容区域——存储经编码转换后的内容。
   - 编码方式有两种：整数型与字节型，取决于输入内容是否可被作为ASCII码转换为不大于64位的有符号整数
   - 为了最小化使用空间，编码信息与长度进行混合存储，`编码及长度区域`的第一个字节内可能同时包含编码信息和部分长度信息
   - 由于条目的`前一节点长度区域`长度因前一节点长度大小不同可能占用1字节，也可能占用5字节，因此在进行插入和删除操作时，可能会导致可向后传导的对`前一节点长度区域`的修正，
     因此插入与删除动作的时间复杂度为O(n)
   - 因为zipentry同时记录了自身长度及前一节点长度，因此ziplist支持向前向后遍历两种方式