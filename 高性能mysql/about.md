> 本文主要内容来源于《高性能MySql第三版》一书

# MySql架构

- 查询与存储分离，以下两种功能在架构上是完全解耦的
  - 查询任务、其他系统任务
  - 数据存储与提取
- 架构上整体分为三层
  - 第一层: 负责处理连接、管理连接线程
  - 第二层: 提供核心服务能力，包括查询解析、分析、优化、缓存以及所有内置函数。所有的跨存储引擎的功能实现都在这一层
  - 第三层: 存储引擎。负责数据的存储与提取。一般来说不同的存储引擎之间不会直接通信，只响应上一层的请求。
    一种例外情况如InnoDB会解析外键定义，以提供MySql服务无法提供的外键操作。

# 基本概念

## 并发控制

- 使用读写锁，进行迸发安全控制

### 表锁

- 表锁会锁定整张表， **是MySql中最基本的锁策略**，其开销最小（粒度最粗）
- 写锁比读锁拥有更高的优先级，写锁请求可能会被 插入到读锁请求之前（反之不成立）
- 存储引擎会管理自己的锁，但MySql在一些情况下还是会使用表锁，忽略存储引擎的锁，来实现不同的目的，比如`ALTER TABLE`操作

### 行锁

- 行锁可以最大程度地支持迸发处理，其开销最大（粒度最小）
- **行级锁只在存储引擎层实现**，而MySql服务器层没有实现，服务层也完全不了解存储引擎中的实现

## 事务

- 事务就是一组原子性的SQL查询
- 事务需要必须满足`ACID`特性:
  - 原子性(Automatic): 不可分割，要么全部执行，要么全部失败回滚
  - 一致性(Consistency): 数据库总是从一个一致性状态转换到另外一个一致性的状态——中间状态的结果不会保存到数据库
  - 隔离性(Isolation): 一个事务所做的修改在最终提交以前，对其他事务不可见
  - 持久性(Durability): 一旦事务提交，其所做的修改就会永久保存到数据库中。即使数据库崩溃，个性的数据也不会丢失
- `ACID`特性要求数据库系统做更多的额外操作，相对于无事务的数据库性能有明显的降低
- MySql允许用户根据业务选择合适的存储引擎，并在无事务的场景下，通过`LOCK TABLES`提供一定程度的安全控制

### 隔离级别

SQL标准中，定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。
不同的存储引擎实现的隔离级别也不尽相同。

- 未提交读(Read Uncommitted): 又称为“脏读”。事务中的修改，即使没有提交，对其他事务也都是可见的。实际很少使用
- 提交读(Read Committed): 一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（Nonrepeatable Read)，因为一个事务的两次执行同样的查询，可能会得到不一样的结果。该级别是大部分数据库系统的默认隔离级别。
- 可重复读(Repeatable Read): 该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。幻读(Phantom Read)指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和 XtraDB存储引擎通过多版本并发控制解决了幻读的问题。该级别是MySQL的默认事务隔离级别
