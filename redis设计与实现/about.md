# Redis设计与实现

> 基于redis仓库提交: 84b3c18f7

## 数据结构

1. 动态字符串
   - 相关文件: sds.h sds.c
   - 多种长度类型: sdshdx，区别在于结构体首端用于记录buf已用长度与分配长度的整形不同(uint8_t,uint16_t ...)
   - 动态分配大小，当字符串长度小于1M时，x2增长，否则+1M
2. 链表-list
   - 相关文件: adlist.h adlist.c
3. 字典-dict
   - 相关文件: dict.h dict.c
   - 通过hash实现，当hash冲突时，使用链表解决，dict会记录hash表长度(length)及总数据数(used)
   - 当哈希冲突超过阈值时，会将hash表扩张至二倍。当dict_can_resize为真时，阈值为used>=length，否则为used / length > dict_force_resize_ratio (默认为5)
   - 扩张后会进行rehash，但该过程为渐进的式的，此时dict会持有两张hash表，第二张（新表）的长度为第一张的二倍。
     每次增删改查时，会扫描旧表对非空节点做数据迁移，当迁移了足够多的hash节点或路过了足够多的空节点时，停止扫描并记录下一次扫描位置。
     迁移完成后，释放旧表，并进行翻转
4. 跳跃表: zskiplist
   - 相关文件: server.h z_zset.c
   - 跳跃表是在普通双向链表的基础上，在每个节点随机生成若干层（层数不小于1不大于32）
   - 当从head向tail遍历时，最下层形成了简单双向链表，节点间span为1，而层i(i>1)的span则记录了距离下一个层i节点的距离
   - zskiplist为每个节点记录分数，分值为该节点到尾部的距离，该分值可通过遍历时累计span获得
   - 通过尽可能使用高层进行跳跃式遍历，将平均查找复杂度控制在O(logN)，最坏O(N)
   - 另一方面，由于需要维护节点每层的span值，因此插入时间复杂度为O(N)
5. 整数集合-intset
   - 相关文件: intset.h intset.c
   - 为了节均空间，intset的整数类型尽可能选小，初始使用int16类型。当插入数据超过范围时，再使用较大一级的整型，并扩充空间
   - intset为有序数组，查找时使用二分查找，时间复杂度为O(logN)
   - 每次插入数据都需要扩容，并使用内容拷贝的方式将插入位空出来，时间复杂度与查找一致
   - 需要注意的是intset在节点删除后，并不会尝试更小的数据类型