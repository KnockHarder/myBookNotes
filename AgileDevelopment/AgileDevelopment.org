* 敏捷开发
** 敏捷联盟宣言
- 个体和交互胜过过程和工具 :: 人是获得成功的最为重要的因素。如果团队中没有优秀的成员，那么就是使用好的过程也不能从失败中挽救项目。
		  但是，孬的过程却可以使最优秀的团队成员推动盗用。如果不能作为一个团队进行工作，那么即使拥有最优秀的成员也一样会惨败。
- 可以工作的软件胜过面面俱到的文档 :: 对于团队来说，编写并维护一份系统原理和结构方面的文档将总是一个好主意，
     但是那套文档应该是短小并且主题突出的。
- 客户合作胜过合同谈判 :: 成功的项目需要有序、频繁的客户反馈。不是依赖于合同或者关于工作的陈述，
		而是让软件的客户和开发团队密切地在一起工作，并尽量经常地提供反馈。
- 响应变化胜过遵循计划 :: 计划不能考虑得过远。道德，商务环境很可能会变化，这会会引起需求的变动。其次，一旦客户看到系统开始运作，
		他们很可能会改变需求。最后，即使我们熟悉需求，并且确信它们不会发迹，我们仍然不能很好地估算出开发它们需要的时间。
** 敏捷开发的原则
1. 我们最优先要做的是通过尽早的、待续的交付有价值的软件来使客户满意
2. 即使到了开发的后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势。
3. 经常性地交付可以工作的软件，交付的间隔可以从几周到几个朋，交付的时间间隔越短越好。
4. 在整个项目开发期间，业务人员和开发人员必须天天都在一起工作。
5. 围绕被激励起来的个人来构建项目。给他们提供所需要的环境和支持，并且信任他们能够完成工作。
6. 在团队内部，最具有效果并且富有效率的传递信息的方法，就是面对面的交谈。
7. 工作的软件是首要的进度度量标准。
8. 敏捷过程提倡可持续的开发速度。责任人、开发者和用户应该能够保持一个长期的、恒定的开发速度。
9. 不能地关注优秀的技能和好的设计会增强敏捷能力。
10. 简单──使未完成的工作最大化的──是根本的。
11. 最好的构架、需求和设计出自于自组织的团队。
12. 每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整。

* 极限编程
极限编程是敏捷方法中最著名的一个。它由一系列简单却互相依赖的实践组成。这些实践结合在一起形成了一个胜于部分结合的整体。

1. 客户作为团队成员
2. 用户素材
3. 短交付周期
4. 验收测试
5. 结对编程
6. 测试驱动的开发方法
7. 集体所有权
8. 持续集成
9. 可持续的开发速度
10. 开放的工作空间
11. 计划游戏
12. 简单的设计
13. 重构
14. 隐喻

* 设计原则
** 单一职责原则（SRP）
- 定义 :: 就一个类而言，应该仅有一个引起它变化的原因。
- 什么是职责 :: 在SRP中,我们把职责定义为“变化的原因”。如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责。
	   有时,我们很难注意到这一点。我们习贯于以组的形式去考虑职责。
** 开放——封闭原则（OCR）
- 定义 :: 软件实体（类、模块、函数等等）应该是可以扩展的，但是不可修改的。

*** 遵循开放──封闭原则设计出的模块具有两个主要的特征
- 对于扩展开放 :: 模块的行为是可以扩展的。当应用的需求改变时，我们可以对模块进行扩展，使其具有满足那些改变的新行为。
- 对于更改是封闭的 :: 对模块行为进行扩展时，不必改动模块的源代码或者二进制代码。模块的二进制可执行版本，
	      无论是可链接的库、DLL或者Java的.jar文件，都无需改动。
** Liskov替换原则（LSP）
- 定义 :: 子类型必须能够替换掉它们的基类型。
- 相对满足 :: 事实上，一个模型，如果孤立地看，里氏替换并不具有真正意义上的有效性，模型的有效性只能通过它的客户程序来表现。
- 启发示方法 ::
  1. 在派生类中存在退化函数并不总是表示违反了LSP，但是当这种情况存在时，
  2. 当在派生类中添加了其基类不会抛出的异常时，如果基类的使用者不期望这些异常，那么把它们添加到派生类的方法中应付导致不可替换性。
     此时要遵循LSP，要么就必须改变使用者的期望，要么派生类就不应该抛出这些异常。
** 依赖倒置原则（DIP）
- 定义 ::
  - 高层模块不应该依赖于低层模块，二者都应该位赖于抽象。
  - 抽象不应该依赖于细节，细节应该依赖于抽象。
- 解释 :: 请注意这里的倒置不仅仅是依赖关系的倒置，它也是接口所有权的倒置。当应用了DIP时，往往是客户拥有抽象接口，
	而它们的服务者则从这些抽象接口派生。
- 启发示规则──领事于抽象 ::
  - 任何变量都不应该持有一个指向具体类的指针或者引用。
  - 任何类都不应该从具体类派生。
  - 任何方法都不应该覆写它的任何基类中的已经实现了的方法。
  - 如果一个具体类不太会改变，并且也不会创建其他类似的派生类，那么依赖于它并不会造成损害。
** 接口隔离原则（ISP）
- 定义 :: 不应该强制客户领事于它们不用的方法。如果强迫客户程序依赖于那些它们不使用的方法，
	那么这些客户程序就面临着由于这些未使用方法的改变所带来的变更，这无意中导致了所有客户程序之间的耦合。
* 常用设计模式
** Command模式和Active Object
*** Command模式的优点
1. 通过对命令概念的封装，可以解除系统的逻辑互联关系和实际连接的设备之前的耦合。
2. 另一个Command模式的常见用法是创建和执行事务操作。
3. 解耦数据和逻辑，可以将数据放在一个列表中，以后再进行实际的操作。
*** Active Object模式
- 描述 :: Active Object模式是实现多线程控制的一项古老的技术。
	控制核心对象维护了一个Command对象的链表。用户可以向链表中增加新的命令，或者调用执行动作，该动作只是遍历链表，执行并去除每个命令。
- RTC任务 :: 采用该技术的变体一去构建多线程系统已经是并且将会一直是一个很常见的实践。这种类型的线程被称为run-to-completion任务（RTC），
	 因为每个Command实例在下一个Command补全可以运行之前就运行完成了。RTC的名字意味着Command实例不会阻塞。
- 共享运行时堆栈 :: Command实例一经运行就一定得完成的的赋予了RTC线程有趣的优点，寻就是它们共享同一个运行时堆栈。和传统的多线程中的线程不同，
	     不必为每个RTC线程定义或者分配各处的运行时堆栈。这在需要大量线程的内存受限系统中是一个强大的优势。
** Template Method模式和Strategy模式：继承和委托 
*** Template Method模式
- 描述 :: Template Method模式展示了面向对象编程上诸多经典重用形式中的一种。其中通用算法被放置在基类中，
	并且通过继承在不同的具体上下文实现该通用算法。
- 代价 :: 继承是一种非常强的关系，派生类不可避免地要和它们的基类绑定在一起。
*** Strategy模式
- 描述 :: Strategy模式使用了一种非常不同的方法来倒置通用算法和具体实现之间的依赖关系。不是将通用的应用算法放进一个抽象基类中，
	而是将它放进一个具体类中，在该具体类中定义一个成员对象，该成员对象实现了实际需要执行的具体算法，
	在执行通用算法时，把具体工作委托给这个成员对象的所实现的抽象接口去完成。
*** 对比
- 共同点 :: Template Method模式和Strategy模式都可以用来分离高层的算法和的具体实现细节，都允许高速的算法独立于它的具体实现细节重用。
- 差异 :: Strategy模式也允许具体实现细节独立于高层的算法重用，不过要惟一些额外的复杂性、内存以及运行时间开销作为代价。

** Facade模式和Mediator模式
*** facade模式
- 使用场景 :: 当想要为一组具有复杂且全面的接口的对象提供一个简单且特定的接口时，可以使用Facade模式，如下图所示的场景。
#+ATTR_HTML: :width 400 :title Facade模式封装数据库操作 
#+CAPTION: Facade模式封装数据库操作
[[file:dbFacade.png][DB Facade]]
- 基于约定 :: 使用Facade模式意味着开发人员已经接受了所有数据库调用都要通过DB类的约定。如果任务一部分代码越过该Facade直接去访问java.sql，
	  那么就违反了该约定。基于约定，DB类成为了java.sql包的惟一代理。
*** Mediator模式
- 示例 :: 图中展示用一个JList和一个JTextField构造了一个QuickEntryMediator类的实例。QuickEntryMediator向JTextField注册了一个匿名的
DocumentListener，每当文本发生变化时,这个listener就调用textFieldChanged方法。接着，该方法在JList中査找以这个文本为前缀的元素并选中它。
JList和JTextField的使用者并不知道该Mediator的存在。它安静地呆着，把它的策略施加在那些对象上，而无需它们的允许或者知晓。
#+ATTR_HTML: :width 400 :title Facade模式封装数据库操作 
#+CAPTION: Facade模式封装数据库操作
[[file:Mediator%E6%A8%A1%E5%BC%8F.png][QuickEntryMediator]]
*** 对比
- 相同点 :: 两个模式都有着共同的目的，它们都把某种策略施加到另外一组对象上，这些对象不需要知道具体的策略细节。
- 不同点 :: Facade通常是约定的关注点，每个人都同意去使用该facade而不是隐藏于其下的对象；而Mediator则对用户是隐藏的，
它的策略是既成事实而不是一项约定事务。
** Singleton模式和Monostate模式
*** Singleton模式
- 描述 :: Singleton是一个很简单的模式。Singleton实例是通过公有的静态方法instance()访问的，即使instance方法被多次调用，
每次返回的都是指向完全相同的实例的引用。Singleton类没有公有构造函数，所以如果不使用instance方法，就无法去创建它的实例。
- 优点 :: 
  1. 跨平台。使用合适的中间件(例如RMI)，可以把Singleton模式扩展为跨多个JVM和多个计算机工作
  2. 适用于任何类：只需把一个类的构造函数变成私有的，并且在其中增加相应的静态函数和变量，就可以把这个类变为Singleton
  3. 可以透过派生创建：给定一个类，可以创建它的一个Singleton子类。
  4. 延迟求值(Lazy Evaluation):如果Singleton从未使用过,那么就决不会创建它。
- 代价 :: 
  1. 摧毁方法未定义：没有好的方法去推毁(destroy)一个Singleton，或者解除其职责。即使添加一个decommission方法把theInstance置为null，
  系统中的其他模块仍然持有对该Singleton实例的引用。这样，随后对instance方法的调用会创建另外一个实例，致使同时存在两个实例。
  这个问题在C++中尤为严重，因为实例可以被推毁，可能会导致去提领(dereference)一个已被摧毁的对象。
  1. 不能继承：从Singleton类派生出来的类并不是Singleton。如果要使其成为Singleton，必须要增加所需的静态函数和变量。
  2. 效率问题：每次调用instance方法都会执行语句。就大多数调用而言，语句是多余的。（使用JAVA的初始化功能可避免）
  3. 不透明性：Singleton的使用者知道它们正在使用一个Singleton，因为它们必须要调用instance方法
*** Monostate模式
- 描述 :: 该模式通过把所有的变量都变成静态变量，使所有实例表现得象一个对象一样。
- 优点 :: 
  1. 透明性：使用Monostate对象和使用常规对象没有什么区别，使用者不需要知道对象是Monostate 
  2. 可派生性：Monostate的派生类都是Monostate。事实上，Monostate的所有派生类都是同一个Monostate的一部分。它们共享相同的静态变量。
  3. 多态性：由于Monostate的方法不是静态的，所以可以在派生类中覆写它们。因此，不同的派生类可以基于同样的静态变量表现出不同的行为。
- 代价 :: 
  1. 不可转换性：不能透过派生把常规类转换成Monostate类。
  2. 效率问题：因为Monostate是真正的对象，所以会导致许多的创建和摧毁开销。
  3. 内存占用：即使从未使用Monostate，它的变量也要占据内存空间。
  4. 平台局限性：Monostate不能跨多个JVM或者多个平台工作。
*** 对比
1. Singleton模式使用私有构造函数和一个静态变量，以及一下静态方法对实例化进行控制和限制；Monostate模式只是简单地把对象的所有变量变成静态的。
2. 如果希望通过派生去约束一个现存类，并且不介意它的所有调用都都必须要调用instance方法来获取访问权，那么Singleton是最合适的。
3. 如果希望类的单一性本质对使用者透明，或者希望使用单一对象的多态派生对象，那么Monostate是最合适的。
** Null Object模式
#+BEGIN_SRC java
Employee e = DB.getEmployee("Bob");
if (e != null && e.isTimeToPay(today))
  e.pay();
#+END_SRC
- 场景 :: 考虑如上代码，我们常使用这&&这样的表达式进行空值检查，大多数人也曾由于忘记进行null检查而受挫。该惯用方法虽然常见，
但却是丑陋且易出错的。通过让getEmployee方法抛出异常，可以减少出错的可能，但try/catch块比null检查更加丑陋。
这种场景下可以使用Null Object模式来解决这些问题（如下图所示）。
[[file:NullObejct%E6%A8%A1%E5%BC%8F.png][Null Obejct模式]]
* 包的设计原则
** 包的内聚性原则
*** 重用发布等价原则（Release Reuse Equivalency Principle）
- 定义 :: 重用的粒度就是发布的粒度

RFP指出，一个包的重用粒度可以和发布粒度一样大，我们所重用的任何东西都必须同时被发布和跟踪。
简单的编写一个类，然后声称它是可重用的做法是不现实的。只有在建立一个跟踪系统，为潜在的使用者提供所需要的变更通知、安全性以及支持后，
重用才有可能。
*** 共同重用原则（Common Reuse Principle）
- 定义 :: 一个包中的所有类应该是共同重用的。如果重用了包中的一个类，那么就要重用包中的所有类。

类很少会孤立的重用，一般来说，可重用的类需要与作为该可重用抽象一部分的其他类协作。

CRP规定了这些类应该属于同一个包。在这样的一个包中，我们会看到类之间有很多的互相依赖。一个简单的例子是容器类以及与它关联的迭代器类，
这些类彼此之间紧密耦合在一起，因此必须共同重用，所以它们应该在同一个包中。

因此，我想确信当我依赖于一个包时，我将依赖于那个包中的每一个类。换句话说，我想确信我放入一个包中的所有类是不可分开的，
仅仅依赖于其中一部分的情况是不可能的。否则，我将要进行不必要的重新验证和重新发行，并且会白费相当数量的努力。
*** 共同封闭原则（Common Closure Principle）
- 定义 :: 包中的所有类对于同一类性质的变化应该是共同封闭的。一个变化若对一个包产生影响，则将对该包中的所有类产生影响，
而对于其他的包不造成任何影响。

这是单一职责原则对于包的重新规定。正如SRP规定的一个类不应该包含多个引起变化的原因那样，这条原则规定了一个包不应该包含多个引起变化的原因。

CCP鼓励我们把可能由于同样的原因而更改的所有类共同聚集在同一个地方。如果两个类之间有非常紧密的绑定关系，不管是物理上的还是概念上的，
那么它们总是会一同进行变化，因而它们应该属于同一个包中。这样做会减少软件的发布、重新验证、重新发行的工作量。
CCP通过把对于一些确定的变化类型开放的类共同组织到同一个包中，从而增强了上述内容。因而，当需求中的一个变化到来时，
那个变化就会很有可能被限制在最小数量的包中。
*** 总结
过去，我们对内聚性的认识要远比上面3个原则所蕴含的简单，我们习惯于认为内聚性不过是指一个模块执行一项并且仅仅一项功能。
然而，这3个关于包内聚性的原则描述了有关内聚性的更加丰富的变化。在选择要共同组织到包中的类时，必须要考虑可重用性与可开发性之间的相反作用力。
在这些作用力和应用的需要之间进行平衡不是一件简单的工作。此外，这个平衡几乎总是动态的。
也就是说，今天看起来合适的划分到了明年也许就不再合适了。
因此，当项目的重心从可开发性向可重用性转变时，包的组成很可能会变动并随时问而演化。
** 稳定性：包的耦合性原则
*** 无环依赖原则
- 定义 :: 在包的依赖关系图中不允许存在环

如果开发环境中存在有许多开发人员都在更改相同的源代码文件集合的情况，那么就会出现因为他人的更改导致你无法构建的情况。
当项目和开发团队的规模增长时，这种问题就会带来可怕的噩梦，每个人都忙于一遍遍地更改他们的代码，试图使之能够相容于其他人所做的最近更改。

通过将开发环境划分成可发布的包，可以解决这个问题，这些包可以作为工作单元被一个开发人员或者一个开发团队修改，将一个包可以工作时，
就把它发布给其他开发人员使用。因此，所有的开发团队都不会受到其他开发团队的支配，对一个包作的理性不必立即反应至其他开发团队中，
每个开发团队独立决定何时采用上前所使用的包的新版本。此外，集成是以小规模增量的方式进行。

这是一个非常简单、合理的过程，并被广泛使用。不过，要使其能够工作，就必须要对包的依赖关系结构进行管理，包的依赖关系结构中不能有环。
