> 本文主要内容来源于《高性能MySql第三版》一书

# MySql架构

- 查询与存储分离，以下两种功能在架构上是完全解耦的
  - 查询任务、其他系统任务
  - 数据存储与提取
- 架构上整体分为三层
  - 第一层: 负责处理连接、管理连接线程
  - 第二层: 提供核心服务能力，包括查询解析、分析、优化、缓存以及所有内置函数。所有的跨存储引擎的功能实现都在这一层
  - 第三层: 存储引擎。负责数据的存储与提取。一般来说不同的存储引擎之间不会直接通信，只响应上一层的请求。
    一种例外情况如InnoDB会解析外键定义，以提供MySql服务无法提供的外键操作。

# 基本概念

## 并发控制

- 使用读写锁，进行迸发安全控制

### 表锁

- 表锁会锁定整张表， **是MySql中最基本的锁策略**，其开销最小（粒度最粗）
- 写锁比读锁拥有更高的优先级，写锁请求可能会被 插入到读锁请求之前（反之不成立）
- 存储引擎会管理自己的锁，但MySql在一些情况下还是会使用表锁，忽略存储引擎的锁，来实现不同的目的，比如`ALTER TABLE`操作

### 行锁

- 行锁可以最大程度地支持迸发处理，其开销最大（粒度最小）
- **行级锁只在存储引擎层实现**，而MySql服务器层没有实现，服务层也完全不了解存储引擎中的实现

## 事务

- 事务就是一组原子性的SQL查询
- 事务需要必须满足`ACID`特性:
  - 原子性(Automatic): 不可分割，要么全部执行，要么全部失败回滚
  - 一致性(Consistency): 数据库总是从一个一致性状态转换到另外一个一致性的状态——中间状态的结果不会保存到数据库
  - 隔离性(Isolation): 一个事务所做的修改在最终提交以前，对其他事务不可见
  - 持久性(Durability): 一旦事务提交，其所做的修改就会永久保存到数据库中。即使数据库崩溃，个性的数据也不会丢失
- `ACID`特性要求数据库系统做更多的额外操作，相对于无事务的数据库性能有明显的降低
- MySql允许用户根据业务选择合适的存储引擎，并在无事务的场景下，通过`LOCK TABLES`提供一定程度的安全控制

### 隔离级别

SQL标准中，定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。
不同的存储引擎实现的隔离级别也不尽相同。

- 未提交读(Read Uncommitted): 又称为“脏读”。事务中的修改，即使没有提交，对其他事务也都是可见的。实际很少使用
- 提交读(Read Committed): 一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（Nonrepeatable Read)，因为一个事务的两次执行同样的查询，可能会得到不一样的结果。该级别是大部分数据库系统的默认隔离级别。
- 可重复读(Repeatable Read): 该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。幻读(Phantom Read)指当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。InnoDB和 XtraDB存储引擎通过多版本并发控制解决了幻读的问题。该级别是MySQL的默认事务隔离级别
- 可串行化(Serializable): 最高的隔离级别,强制事务串行执行。该级别下，会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。
	实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的一致性而且可以接受没有并发的情况下，才考虑采用该级别。

### 死锁

当多个事务并发的请求资源占用时，可能产生死锁现象。为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。
越复杂的系统(如InnoDB存储引擎），越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。
另一种解决方式，就是当查询时间达到锁等待超时后放弃锁请求，这种方式通常来说不太好。

锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。
死锁的产生有双重原因：有些是因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。

死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，这是无法避免的。
所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。
InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。

### 事务日志

使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该 **修改行为** 记录到持久在硬盘上的事务日志中，而不是直接持久到磁盘。
追加事务日志只用操作是磁盘上一小块区域内的顺序IO，采用事务日志的方式相对同步数据变化至磁盘的随机IO来说要快得多。
事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。

目前大多数存储引擎都是这样实现的，我们通常称之为预写式日志（Write Ahead Logging），修改一次数据需要写两次磁盘。

如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，
那么存储引擎在重启时能够自动恢复这部分修改的数据。具体的恢复方式则视存储引擎而定。

# Mysql中的事务

MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。

## 自动提交模式

MySQL默认采用自动提交(Auto-commit)模式。即如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。

可通过设置`AUTOCOMMIT`变量来启用或者禁用自动提交模式。
- 当禁用自动提交时，所有的查询都是在一个事务中，直到显式地执行`COMMIT`提交或`ROLLBACK`回滚。在该事务结束的同时也就开启了另一个新事务。
- 修改`AUTOCOMMIT`对非事务型的表（如MyISAM、内存表），不会有任何影响。对这类表来说，没有`COMMIT`或者`ROLLBACK`的概念，
	也可以认为其一直处于自动提交模式下。
- 还有一些命令，在执行之前会强制执行`COMMIT`提交当前的活动事务。例如DDL中导致大量数据改变的操作（如`ALTER TABLE`)，
	以及`LOCK TABLES`等其他语句。具体可检查对应版本的官方文档来确认所有可能导致自动提交的语句列表。

## 设置隔离级别

MySQL可以通过执行`SET TRANSACTION ISOLATION LEVEL`命令来设置隔离级别。
可以在配置文件中设置整个数据库的隔离级别，也可以只改变当前会话的隔离级别:

## 混合使用存储引擎会带来问题

**MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。**

这意味着在同一个事务中，使用多种存储引擎是不可靠的。
例如在事务中混合使用了事务型和非事务型的表(如InnoDB和MyISAM表)，在正常提交的情况下不会有什么问题。
但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态。

这种情况很难修复，事务的最终结果将无法确定所以，为每张表选择合适的存储引擎非常重要。

> 在非事务型的表上执行事务相关操作时，MySQL通常不会发出提醒，也不会报错。
> 有时候只有回滚的时候才会发出一个警告:“某些非事务型的表上的变更不能被回滚”。
> 但大多数情况下，对非事务型表的操作都不会有提示。

## 隐式和显式锁定

InnoDB采用的是两阶段锁定协议(two-phase locking protocol）。
在事务执行过程中，随时都可以执行锁定，锁只有在执行`COMMIT`或者`ROLLBACK`的时候才会释放，并且所有的锁是在同一时刻被释放。
这些锁定是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。

另一种锁定的方式，是通过特定的语句进行显式的锁定。
如InnoDB中的`SELECT ... LOCK IN SHARE MODE`、`SELECT ... FOR UPDATE`，这些语句不属于SQL规范。

### 服务器层提供的锁定能力

MySQL也支持`LOCK TABLES`和`UNLOCK TABLES`语句，但这是在服务器层实现的，和存储引擎无关。

当将一个表从MyISAM转换到InnoDB时，如果还显式地使用`LOCK TABLES`语句。这不但没有必要，还会严重影响性能，实际上InnoDB的行级锁工作得更好。
另一方面，`LOCK TABLES`和事务之间相互影响的话，情况会变得非常复杂，在某些MySQL版本中甚至会产生无法预料的结果。
因此实际使用时，除了事务中禁用了`AUTOCOMMIT`的场景下可以使用`LOCK TABLES`之外，其他时候不要显式地执行`LOCK TABLES`，不管使用的是什么存储引擎。

事实上`LOCK TABLES`等语句它们有自己的用途，但并不能替代事务处理，如果应用需要用到事务，还是应该选择事务型存储引擎。

# 多版本并发控制

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制(MVCC)。
可以认为MVCC是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。

> 不仅是MySQL，包括 Oracle、 PostgreSQL等其他数据库系统也都实现了MVCC，但各自的实现机制不尽相同，因为MVCC没有一个统一的实现标准。
> 典型的实现区分有乐观(Optimistic)和悲观(Pessimistic)并发控制。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行。

MVCC是通过保存数据在某个时间点的快照来实现的。也就是说，事务内看到的数据都是一致的，不管需要执行多长时间。
根据事务开始的时间不同，每个事务对同一张表、同一时刻看到的数据可能是不一样的。

## InnoDb的MVCC实现

InnoDB会在每行记录后面保存两个隐藏的列，一列保存行的创建时间，一列保存行的过期时间（或删除时间）。
这里所指的时间并不是时间戳，而是系统版本号。

每开始一个新的事务，系统版本号都会自动递增，并将其作为当前事务的版本号，用来和查询到的每行记录的版本号进行比较。

具体的比较逻辑以 **REPEATABLE READ** 隔离级别为例:
- SELECT: 只有符合下述两个条件的记录，才能返回作为查询结果。
	1. 数据行的创建时间不晚于当前事务版本，这样可以确保事务读取的行，要么是在事务开始前已经存在的，
		 要么是事务自身插入或者修改过的。
	1. 数据行的删除时间要么未定义，要么大于当前事务。这可以确保事务读取到的行，在事务开始之前未被删除。
- INSERT: 为新插入的每一行保存当前事务的系统版本号作为行创建时间。
- DELETE: 为删除的每一行保存当前事务的系统版本号作为行删除时间。
- UPDATE: 插入一行新记录，保存当前事务的系统版本号作为行创建时间，同时更新旧行的删除时间。

## 以空间换取高并发的性能

通过多版本并发控制，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。
不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。

## 只适用于提交读和可重复读隔离级别

MVCC只在 **REPEATABLE READ** 和 **READ COMMITTED** 两个隔离级别下工作。因为 **READ UNCOMMITTED**总是读取最新的数据行，
而 **SERIALIZABLE** 则会对所有读取的行都加锁。

# MySQL中表文件存储

在文件系统中，MySQL将每个数据库(即schema)保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的frm文件保存表的定义。
不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。

> MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在Windows大小写不敏感，而在类Unix中则是敏感的。

## 查看表信息

可以使用`SHOW TABLE STATUS`命令显示表的相关信息。例如，对于mysq数据库中的user表可执行`SHOW TABLE STATUS LIKE 'user'`。
在MySQL5.0以后的版本中，也可以查询INFORMATION＿SCHEMA中对应的表

各字段含义如下:
- Name: 表名。
- Engine: 表的存储引擎类型。（在旧版本中，该列为Type）
- Row format: 行的格式。对于MyISAM表，可选的值为Dynamic、Fixed或者Compressed Dynamic。
	Dynamic的行长度是可变的，一般包含可变长度的字段，如VARCHAR或BLOB。Fixed的行长度则是固定的，只包含固定长度的列，如CHAR和INTEGER。
	Compressed的行则只在压缩表中存在。
- Rows: 表中的行数。对于MyISAM和其他一些存储引擎，该值是精确的，但对于InnoDB，该值是估计值。
- Avg_row_length: 平均每行包含的字节数。
- Data_length: 表数据的大小（以字节为单位）
- Max_data_length: 表数据的最大容量，该值和存储引擎有关。
- Index_length: 索引的大小（以字节为单位）。
- Data_free: 对于MyISAM表，表示已分配但目前没有使用的空间。这部分空间包括了之前删除的行，以及后续可以被`INSERT`利用到的空间。
- Auto_increment: 下一个`AUTO INCREMENT`的值。
- Create_time: 表的创建时间。
- Update_time: 表数据的最后修改时间。
- Check_time: 使用`CKECK TABLE`命令或者 **myisamchk** 工具最后一次检查表的时间。
- Collation: 表的默认字符集和字符列排序规则。
- Checksum: 如果启用，保存的是整个表的实时校验和。
- Create_options: 创建表时指定的其他选项。
- Comment: 该列包含了一些其他的额外信息。对于MyISAM表，保存的是表在创建时带的注释。对于InnoDB表，则保存的是InnoDB表空间的剩余空间信息。
	如果是一个视图，则该列包含“VIEW”的文本字样。
